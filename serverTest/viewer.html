<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>Point Cloud Viewer (VGGT & Viser)</title>

  <!-- three.js (r114) UMD 버전 -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.114.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.114.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.114.0/examples/js/loaders/PLYLoader.js"></script>

  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      background: #050509;
      color: #eee;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }
    body {
      display: flex;
      flex-direction: column;
    }
    header {
      padding: 8px 16px;
      border-bottom: 1px solid #222;
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 13px;
      flex-wrap: wrap;
    }
    label {
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }
    select {
      padding: 3px 6px;
      border-radius: 4px;
      border: 1px solid #444;
      background: #181824;
      color: #eee;
      font-size: 12px;
    }
    button {
      padding: 4px 10px;
      border-radius: 4px;
      border: 1px solid #444;
      background: #2b2b40;
      color: #eee;
      cursor: pointer;
      font-size: 12px;
    }
    button:hover {
      background: #39395a;
    }
    #viewer {
      flex: 1;
      position: relative;
    }
    #overlayMessage {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #aaa;
      font-size: 14px;
      text-align: center;
      pointer-events: none;
    }
    #stat {
      position: absolute;
      left: 10px;
      bottom: 10px;
      font-size: 11px;
      background: rgba(0,0,0,0.4);
      padding: 4px 8px;
      border-radius: 999px;
    }
    #urlText {
      font-size: 11px;
      opacity: 0.8;
    }
    #log {
      font-size: 11px;
      background: rgba(0,0,0,0.6);
      padding: 6px 10px;
      border-top: 1px solid #222;
      max-height: 120px;
      overflow: auto;
      white-space: pre-wrap;
    }
  </style>
</head>
<body>
<header>
  <span><b>Point Cloud Viewer (VGGT + Viser)</b></span>

  <!-- category -->
  <label>
    category:
    <select id="categorySelect">
      <option value="none" selected>(none)</option>
      <option value="backpack">backpack</option>
      <option value="ball">ball</option>
      <option value="book">book</option>
      <option value="bottle">bottle</option>
      <option value="chair">chair</option>
      <option value="cup">cup</option>
      <option value="handbag">handbag</option>
      <option value="laptop">laptop</option>
      <option value="plant">plant</option>
      <option value="teddybear">teddybear</option>
      <option value="vase">vase</option>
    </select>
  </label>

  <!-- codec -->
  <label>
    codec:
    <select id="codecSelect">
      <option value="none" selected>(none)</option>
      <option value="JPEG">JPEG</option>
      <option value="AVC">AVC</option>
    </select>
  </label>

  <!-- Q / QP -->
  <label>
    Q / QP:
    <select id="qpSelect">
      <option value="none" selected>(none)</option>
    </select>
  </label>

  <!-- frame -->
  <label>
    frame:
    <select id="frameSelect">
      <option value="none" selected>(none)</option>
    </select>
  </label>

  <!-- 로드 버튼 -->
  <button id="loadBtn">로드 + 보기</button>

  <span id="urlText"></span>
</header>

<div id="viewer">
  <div id="overlayMessage">
    초기값: category=<b>backpack</b>, codec=<b>JPEG</b>, QP=<b>10</b><br/>
    기준으로 frame 리스트를 자동으로 불러옵니다.<br/><br/>
    값 조정 후 <b>로드 + 보기</b> 버튼을 누르면<br/>
    서버에서 PLY를 받아와서 시각화합니다.
  </div>
  <div id="stat">포인트: 0</div>
</div>

<div id="log">[log] 초기화 중...</div>

<script>
  // === DOM 요소 ===
  const viewer       = document.getElementById('viewer');
  const overlayMsg   = document.getElementById('overlayMessage');
  const statElement  = document.getElementById('stat');
  const logDiv       = document.getElementById('log');

  const categorySelect = document.getElementById('categorySelect');
  const codecSelect    = document.getElementById('codecSelect');
  const qpSelect       = document.getElementById('qpSelect');
  const frameSelect    = document.getElementById('frameSelect');
  const loadBtn        = document.getElementById('loadBtn');
  const urlText        = document.getElementById('urlText');

  let scene, camera, renderer, controls, pointCloud = null;

  const QP_OPTIONS = {
    JPEG: [10, 30, 50, 70],
    AVC:  [27, 37, 47],
  };

  function log(msg) {
    const t = new Date().toISOString().split('T')[1].split('.')[0];
    logDiv.textContent += `\n[${t}] ${msg}`;
    logDiv.scrollTop = logDiv.scrollHeight;
  }

  // === QP 세팅 ===
  function setQPOptions() {
    const codec = codecSelect.value;
    const list = QP_OPTIONS[codec] || [];
    qpSelect.innerHTML = "<option value='none' selected>(none)</option>";
    list.forEach(v => {
      const opt = document.createElement("option");
      opt.value = String(v);
      opt.textContent = String(v);
      qpSelect.appendChild(opt);
    });
    if (list.length > 0) {
      qpSelect.value = String(list[0]); // 기본값 10 or 27
    }
  }

  // === /frames 호출 ===
  async function loadFrames() {
    const category = categorySelect.value;
    const codec    = codecSelect.value;
    const qp       = qpSelect.value;

    frameSelect.innerHTML = "<option value='none' selected>(none)</option>";
    const loadingOpt = document.createElement("option");
    loadingOpt.value = "";
    loadingOpt.textContent = "(loading...)";
    frameSelect.appendChild(loadingOpt);

    if (category === "none" || codec === "none" || qp === "none") {
      return; // 선택된 값이 없으면 처리하지 않음
    }

    const url =
      `/frames?category=${encodeURIComponent(category)}` +
      `&codec=${encodeURIComponent(codec)}` +
      `&qp=${encodeURIComponent(qp)}`;

    log(`요청: GET ${url}`);

    try {
      const res = await fetch(url);
      log(`응답: /frames status = ${res.status}`);
      if (!res.ok) {
        frameSelect.innerHTML = "";
        const opt = document.createElement("option");
        opt.value = "";
        opt.textContent = `(error ${res.status})`;
        frameSelect.appendChild(opt);
        return;
      }
      const list = await res.json();
      log(`응답 JSON: ${JSON.stringify(list)}`);

      frameSelect.innerHTML = "<option value='none' selected>(none)</option>";
      if (!Array.isArray(list) || list.length === 0) {
        const opt = document.createElement("option");
        opt.value = "";
        opt.textContent = "(no frames)";
        frameSelect.appendChild(opt);
        return;
      }
      list.forEach((f) => {
        const opt = document.createElement("option");
        opt.value = String(f);
        opt.textContent = String(f);
        frameSelect.appendChild(opt);
      });
      frameSelect.value = String(list[0]);
      log(`frameSelect 기본 선택값 = ${list[0]}`);
    } catch (e) {
      log(`예외 발생(loadFrames): ${e}`);
      frameSelect.innerHTML = "<option value='none' selected>(none)</option>";
      const opt = document.createElement("option");
      opt.value = "";
      opt.textContent = "(fetch error)";
      frameSelect.appendChild(opt);
    }
  }

  // === /ply 호출 + PLYLoader ===
  async function loadAndViewPly() {
    const category = categorySelect.value;
    const codec    = codecSelect.value;
    const frame    = frameSelect.value;
    const qp       = qpSelect.value;

    if (category === "none" || codec === "none" || qp === "none" || frame === "none") {
      alert("모든 항목을 선택해주세요.");
      return;
    }

    const url =
      `/ply?category=${encodeURIComponent(category)}` +
      `&codec=${encodeURIComponent(codec)}` +
      `&frame=${encodeURIComponent(frame)}` +
      `&qp=${encodeURIComponent(qp)}`;

    urlText.textContent = `요청 URL: ${url}`;
    log(`요청: GET ${url}`);

    // 1) fetch로 서버 응답 확인
    try {
      const res = await fetch(url);
      log(`응답: /ply status = ${res.status}`);

      if (!res.ok) {
        const txt = await res.text();
        log(`에러 body: ${txt}`);
        return;
      }

      const buf = await res.arrayBuffer();
      log(`/ply body 크기 = ${buf.byteLength} bytes (이후 PLYLoader로 다시 로드)`);
    } catch (e) {
      log(`예외 발생(loadAndViewPly - fetch): ${e}`);
      return;
    }

    // 2) THREE / PLYLoader 준비 확인
    if (typeof THREE === "undefined") {
      log("THREE 가 정의되어 있지 않습니다. (three.min.js 로딩 문제)");
      return;
    }
    if (typeof THREE.PLYLoader === "undefined") {
      log("THREE.PLYLoader 가 없습니다. (PLYLoader.js 로딩 문제)");
      return;
    }

    // 3) 실제로 PLYLoader로 시각화
    const loader = new THREE.PLYLoader();
    loader.load(
      url,
      (geometry) => {
        // 1. 로드된 포인트 클라우드의 정보를 로그로 출력
        console.log("PLY 파일 로드 완료!");
        console.log("포인트 수:", geometry.getAttribute('position').count); // 포인트 수 확인

        geometry.computeBoundingBox();  // Bounding Box 계산
        geometry.computeBoundingSphere();  // Bounding Sphere 계산

        // 포인트 클라우드의 크기 및 중심 위치 계산
        const radius = geometry.boundingSphere ? geometry.boundingSphere.radius : 1.0;
        const pointSize = Math.max(0.02, radius * 0.02);  // 점 크기 조정
        const center = geometry.boundingSphere.center.clone(); // 중심점

        // 2. 카메라 위치 자동 설정 (중심점으로 이동)
        camera.position.set(center.x + radius * 2, center.y + radius * 2, center.z + radius * 2);  // 중심에서 일정 거리로 카메라 배치
        camera.near = radius * 0.01;
        camera.far = radius * 10;
        camera.updateProjectionMatrix();

        // 3. 색상 정보를 그대로 사용 (vertexColors: true 설정)
        const material = new THREE.PointsMaterial({
          size: pointSize,
          sizeAttenuation: true,
          vertexColors: true,  // 색상 속성을 그대로 사용
        });

        // 기존에 있던 포인트 클라우드 제거
        if (pointCloud) {
          scene.remove(pointCloud);
          pointCloud.geometry.dispose();
          pointCloud.material.dispose();
        }

        // 새로운 포인트 클라우드로 씬에 추가
        pointCloud = new THREE.Points(geometry, material);
        scene.add(pointCloud);

        // 4. 포인트 클라우드 상태 업데이트
        overlayMsg.style.display = 'none';
        const numPoints = geometry.getAttribute('position').count;
        statElement.textContent = `포인트: ${numPoints.toLocaleString()}`;
        log(`PLY 로딩 완료, 포인트 개수 = ${numPoints}`);
      },
      undefined,
      (error) => {
        console.error("PLY 로딩 에러:", error);
        log(`PLYLoader 에러: ${error}`);
        overlayMsg.textContent = 'PLY 로딩 중 오류 (콘솔과 서버 로그 확인).';
      }
    );
  }

  // === three.js 초기화 ===
  function initThree() {
    const width = viewer.clientWidth || window.innerWidth;
    const height = viewer.clientHeight || (window.innerHeight - 140);

    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x050509);

    camera = new THREE.PerspectiveCamera(60, width / height, 0.01, 1000);
    camera.position.set(0, 0, 3);

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(width, height);
    viewer.appendChild(renderer.domElement);

    controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.08;

    const grid = new THREE.GridHelper(10, 10, 0x444444, 0x222222);
    grid.position.y = -2;
    scene.add(grid);

    const axes = new THREE.AxesHelper(1.0);
    scene.add(axes);

    window.addEventListener('resize', () => {
      const w = viewer.clientWidth || window.innerWidth;
      const h = viewer.clientHeight || (window.innerHeight - 140);
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
      renderer.setSize(w, h);
    });

    function animate() {
      requestAnimationFrame(animate);
      if (controls) controls.update();
      renderer.render(scene, camera);
    }
    animate();
  }

  // === 이벤트 & 초기화 ===
  codecSelect.addEventListener('change', () => {
    setQPOptions();
    loadFrames();
  });
  categorySelect.addEventListener('change', () => {
    loadFrames();
  });

  loadBtn.addEventListener('click', () => {
    log("로드 버튼 클릭됨");
    loadAndViewPly();
  });

  window.addEventListener('load', () => {
    initThree();
    setQPOptions();   // codec=JPEG → QP=10
    loadFrames();     // backpack / JPEG / QP=10 기준으로 frame 목록 요청
    log("초기화 완료: category=backpack, codec=JPEG, QP=10 기준으로 /frames 호출함.");
  });
</script>
</body>
</html>
